

= jMonkeyEngine 3 Урок (4) - Знакомство с циклом обновления

Предыдущий: <<документация/jme3_ru/начальная/знакомство_с_ресурсами#,Знакомство с Ресурсами>>,
Следующий: <<документация/jme3_ru/начальная/знакомство_с_системой_ввода#,Знакомство с системой ввода>>,
Английская версия: <<jme3/beginner/hello_main_event_loop#,Hello Loop>>


Теперь, когда вы знаете, как загружать ресурсы, такие как 3D-модели, которыми вы хотите реализовать некоторые геймплей, для которого они нужны. В этом уроке мы рассмотрим цикл обновления. Действия вашей игры происходят в цикле обновления.



== Пример Кода

[source,java]

----

package jme3test.helloworld;

import com.jme3.app.SimpleApplication;
import com.jme3.material.Material;
import com.jme3.math.ColorRGBA;
import com.jme3.scene.Geometry;
import com.jme3.scene.shape.Box;

/** Образец 4 - Как триггер, повторяя действия из основного цикла обработки событий.
 * В этом примере используется цикл, чтобы создать впечатление
 * непрерывного вращения. */
public class HelloLoop extends SimpleApplication {

    public static void main(String[] args){
        HelloLoop app = new HelloLoop();
        app.start();
    }

    protected Geometry player;

    @Override
    public void simpleInitApp() {
        /** этот синий куб это характеристики нашего player */
        Box b = new Box(1, 1, 1);
        player = new Geometry("blue cube", b);
        Material mat = new Material(assetManager,
          "Common/MatDefs/Misc/Unshaded.j3md");
        mat.setColor("Color", ColorRGBA.Blue);
        player.setMaterial(mat);
        rootNode.attachChild(player);
    }

    /* Использование основного цикла событий, чтобы вызвать повторяющиеся действия. */
    @Override
    public void simpleUpdate(float tpf) {
        // make the player rotate:
        player.rotate(0, 2*tpf, 0); 
    }
}
----

Построить и запустить файл: вы видите постоянно вращающийся куб.



== Понимание кода

По сравнению с нашим предыдущим образцом кода, обратите внимание, что Геометрия player теперь поле класса. Это потому, что мы хотим, чтобы цикл обновления, был в состоянии получить доступ и преобразовать эту Геометрию. Как обычно, мы инициализируем объект игрока в методе `simpleInitApp()`. 


Теперь посмотрим на метод `simpleUpdate()` – это цикл обновления.


*  `player.rotate(0, 2*tpf, 0);` ось вращения объекта игрока. 
*  Мы используем `tpf` переменную (“время в кадре) для времени, этого действия в зависимости от текущего кадра в секунду. Это просто означает, что куб вращается с той же скоростью на быстрых и медленных машин, и игра остается играбельной.
*  Когда игра запускается, код rotate() выполняется снова и снова. 


== Использование цикла обновления

Вращающийся объект-это всего лишь простой пример. В цикле обновления, вы, как правило, многое тестируете и запускаете различные действия игры. В нем вы обновите значение очков здоровья, проверите столкновения, выполните действия врагов и рассчитывается их следующий шаг, бросите кости, определится была ли включена ловушка, воспроизведение звуков окружающей среды и многое другое.


*  Метод `simpleUpdate()` начинает работать после `simpleInitApp()` - метода инициализации графа сцены и переменных состояния.
*  JME3 выполняет все, что в методе `simpleUpdate()` многократно и как можно быстрее.
..  Используйте цикл обновления хода игры, для последующей инициализации действия. 
..  Используйте цикл что бы вызвать реакцию и обновлять состояние игры.
..  Использовать цикл с умом, потому что слишком много вызовов в цикле также замедляет игру.



== Инициализация(Init) - Обновление(Update) - Рендеринг(Визуализация)(Render)

Обратите внимание на три фазы в каждой игре:


*  *Инициализация:* Метод `simpleInitApp()` выполняется только _один раз_, в самом начале;
*  *Обновление:* Метод `simpleUpdate()` выполняется _многократно_, во время игры.
*  *Рендеринг:* После каждого обновления, jMonkeyEngine _автоматически_ перерисовывает (`рендерит`) экран для вас.

Поскольку рендеринг происходит в автоматическом режиме, инициализации и обновления для вас это два самых важных понятий в основе простого игрового приложения:


*  Метод `simpleInitApp()`  приложения “первый вдох. +
Здесь можно создать и загрузить игровые данные (один раз).
*  Метод `simpleUpdate()`  приложения “сердцебиение (в единицу времени называется `ticks`). +
Здесь вы измените их свойства для обновления состояния игры (многократно).




*  Перемещение блоков кода из метода simpleInitApp() в метод <<документация/jme3_ru/расширенная/состояние_приложения#,AppStates>>.
*  Перемещение блоков кода из метода simpleUpdate() в метод <<jme3/advanced/custom_controls#,Custom Controls>>.






== Упражнения

Вот несколько забавных вещей, которые стоит попробовать:


.  Что произойдет, если вы дадите метод rotate() отрицательные числа?
.  Вы можете создать две Geometries рядом друг с другом, и сделать вращение одной из них в два раза быстрее, чем другой? (используя `tpf` переменную)
.  Вы можете сделать пульсирующий куб? (увеличивается и уменьшается)
.  Вы можете сделать куб, который меняет цвет? (изменение и установка Материалов)
.  Вы можете сделать качающийся куб? (вращение вокруг оси X, и перемещения вдоль оси Z))

Вернитесь к <<документация/jme3_ru/начальная/знакомство_с_узлами#,Знакомству с узлами>> если вы не помните методы преобразования для масштабирования, перемещение, и вращения.


<<документация/jme3_ru/решения#,Решения>>
+++<u>Будьте уверены в себе, и попытайтесь решить их в первую очередь для себя!</u>+++



== Вывод

Теперь вы узнали о цикле обновления “сердце игры, и вы можете теперь добавлять в него любые действия. 


Следующее, что игра должна уметь это _взаимо_действие! Продолжить обучение, как <<документация/jme3_ru/начальная/знакомство_с_системой_ввода#,реагировать на действия пользователя>>.

'''

См. также:


*  Дополнительно jME3 разработчики используют <<документация/jme3_ru/расширенная/состояние_приложения#,Состояние приложения>> и <<jme3/advanced/custom_controls#,Custom Controls>>для реализации игровой механики в их цикле обновления. Вам будут попадаться эти темы снова позже, когда вы перейдете к более продвинутой документации.
<tags><tag target="documentation" /><tag target="state" /><tag target="states" /><tag target="intro" /><tag target="beginner" /><tag target="control" /><tag target="loop" /></tags>
