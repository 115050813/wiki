

= Терминология в разработке 3D игр

Прежде чем начать, убедитесь, что вы знакомы со следующими понятиями и терминологией. 



= 3D графика и аудио

*OpenGL* является открытой графической библиотекой независимой от платформы спецификацией для визуализации 2D/3D компьютерной графики. Для Java, есть две реализации OpenGL на основе рендера:


.  Lightweight Java Game Library (LWJGL) – jme3 использует lwjgl.
.  Java OpenGL (JOGL)

*OpenAL* является открытой аудио библиотекой, платформонезависимый 3D аудио +++<abbr title="Application Programming Interface">API</abbr>+++.



= Контекст, дисплей, визуализация

*jME Context* выполняет настройки, визуализацию, таймер, ввод и слушатели событий, display system, доступные для игр jME3.


*  *jME Display System* то что привлекает использовать JME окна (в отличии от Java Swing).
*  *Input System* это компонент, который позволяет реагировать на ввод данных пользователем: кликов мыши и движений, нажатия клавиш на клавиатуре, джойстике.
*  *Renderer* это то, что делает всю работу по расчету рисования 3D графа сцены на 2D-экране.
**  *Shader* является программируемой частью конвейера визуализации.JME3 использует его, чтобы предложить современные способы настройки материалов.



= Геометрия


== Полигон, Сетка, Вершина


image::jme3/dolphin-mesh.png[Модель (дельфин) состоит из сетки полигонов,with="",height="",align="right"]



Большинство видимых объектов в 3D сцене состоят из сетки полигонов(link:https://ru.wikipedia.org/wiki/%CF%EE%EB%E8%E3%EE%ED%E0%EB%FC%ED%E0%FF_%F1%E5%F2%EA%E0[Полигональная сетка]) - персонажи, местность, здания и т.д. сетка представляет собой сетку-как структуру, которая представляет собой сложную форму. Преимуществом сетки является то, что она математически достаточно проста, чтобы работать в режиме реального времени, а также достаточно подробна, чтобы быть узнаваемой.


Каждая форма сводится к ряду многоугольников, как правило это треугольники, даже в круглой поверхности такой как сфера все сводится к сетке треугольников. Точки угла полигонов называются вершинами. Каждая вершина расположена в точке с координатой, все вершины вместе описывают контур формы.


Вы создаете 3D-сетки в инструментах, называемых mesh редакторы, например в Blender. JMonkeyEngine может загрузить законченную сетку (модель) и расположить её на сцене, но он не может отредактировать саму сетку.



= Материалы: Цвет, Освещение/Затенение

То, что мы называем “цвет является лишь частью отражения света от объекта. Мозг наблюдателя использует затенения и отражение как свойства чтобы отобразить форму объекта и материала. Такие факторы, как этот создают различия между мелом и молоком, бумагой и кожей, и т.д.! (link:http://www.shaders.org/ifw2_textures/whatsin10.htm[Примеры извне])



== Цвет


=== Окружающий цвет

*  Однородный базовый цвет сетки - не зависит от любого источника света.
*  Как правило похож на диффузный цвет.
*  Это минимальный цвет который вам нужен что бы увидеть объект.


=== Диффузный цвет

*  Основной цвет сетки плюс свет и тени, которые вызваны источником света.
*  Как правило похоже на окружающий цвет.


== Источники света


=== Эмиссионные цвета

*  Цвет света, излучаемого источником света или светящегося материала.
*  Только светящиеся материалы, такие как огни имеют эмиссионных цвет, нормальное объекты не обладают этим свойством.
*  Часто белый (солнечный свет).


== Отражения


=== Блеск

*  Степень блеска поверхности (1-128).
*  Блестящие предметы имеют небольшие, четко очерченные блики. (Например, стекло, вода, серебро)
*  Нормальные объекты имеют широкие, размытые блики. (Например, металл, пластик, камень, полированный материал)
*  Неравномерные объекты не блестят и не имеют никаких бликов. (Например, ткань, бумага, дерево, снег) +
Установите зеркальный цвет ColorRGBA.Black чтобы выключить блеск.


=== Зеркальный цвет

*  Если материал блестящий, то зеркальный цвет является цветом отраженного.
*  Обычно такой же, как эмиссионный цвета источника света (например, белый).
*  Можно использовать цвета для достижения специальных зеркальных эффектов, таких как металлические или радужные отражения.
*  Неблестящие объекты имеют черный зеркальный цвет.


image::http///img823.imageshack.us/img823/1171/tanlglow2.png[tanlglow2.png,with="400",height="234",align="center"]




= Материалы: Текстуры

Текстуры-часть материалов. В простейшем случае объект может иметь только одну текстуру, цветовую карту, загружаемую из одного файла изображения. Когда вы вспомните старые компьютерные игры вы вспомните как просто это выглядит.


Чем больше информации вы (гейм-дизайнер) отобразите в цветовой карте, тем выше степень детализации и реализма. Если вы хотите фотореалистичной визуализации или “мультяшного рендеринга (Cel Shading)то все зависит от качества ваших материалов и текстур. Современная 3D графика использует несколько слоев информации для описания одного материала, каждый отображает слой текстуры.


link:http://opengameart.org[Скачайте бесплатно текстуры из opengameart.org]



== Наложение текстуры


=== Цветовая карта / Диффузная карта


image::http///jmonkeyengine.googlecode.com/svn/trunk/engine/test-data/Models/HoverTank/tank_diffuse.jpg[tank_diffuse.jpg,with="128",height="128",align="right"]



*  Простой файл изображения или процедурная текстура, которая описывает видимую поверхность объекта.
*  Изображение может иметь альфа-канал для прозрачности.
*  *Цветовая карта-минимум для текстуры* Вы можете отобразить больше текстур в качестве дополнительного усовершенствования. 
*  Незатемненная цветовая карта. То же что и диффузная карта в Phong-подсветке материала, потому что эта текстура определяет основные цвета света, которые рассеиваются _ используемым _ объектом.


=== Карта глубины

Bump карты используются, чтобы описать подробные формы, которые было бы слишком трудно или слишком неэффективно создавать в редакторе. Есть два типа:


*  Вы используете карт нормалей для моделирования мелких деталей, таких как трещины в стенах, ржавчины, текстуру кожи ( (link:http://en.wikipedia.org/wiki/Bump_mapping[Больше о BumpMaps]). 
*  Вы можете использовать карты высот для моделирования больших участков долин и гор.


image::http///jmonkeyengine.googlecode.com/svn/trunk/engine/test-data/Textures/Terrain/splat/mountains512.png[mountains512.png,with="128",height="128",align="right"]




==== Высотные карты

*  Карта высот является черно-белым изображением похожа на карту местности, используется в топографии. Яркие серые цвета представляют более высокие точки и более темные области серого цвета нижнии области.
*  Карта высот может представлять 256 уровней высоты и в основном используется для того чтобы примерно очертить местность.
*  Вы можете нарисовать карту высоты вручную в любом графическом редакторе.


==== Карта Нормалей


image::http///jmonkeyengine.googlecode.com/svn/trunk/engine/test-data/Models/HoverTank/tank_normals.png[tank_normals.png,with="128",height="128",align="right"]



*  Хорошо сделанная карта нормалей делает форму более подробной - без необходимости добавления дорогостоящих полигонов к сетке. Она содержит информацию о затенении, что делает объект ровнее и более четким.
*  Когда вы открываете карту нормалей в графическом редакторе она выглядит как не цветная версия Color Map. Карты нормалей однако никогда не используются для окрашивания, вместо этого, каждое значение цветового пикселя используется для создания трещин и ударов на поверхности. Данные карты представлены нормалями поверхности склонов, отсюда и название.
*  Вы не можете рисовать или редактировать карты нормалей вручную, профессиональные дизайнеры используют программное обеспечение для расчета высококачественных 3D-моделей. Вы можете купить профессиональный набор текстур, или найти бесплатную коллекцию, которая включает карты нормалей.


=== Зеркальная карта


image::http///jmonkeyengine.googlecode.com/svn/trunk/engine/test-data/Models/HoverTank/tank_specular.jpg[tank_specular.jpg,with="128",height="128",align="right"]



*  Зеркальная карта улучшает реализм поверхности объекта: Она содержит дополнительную информацию о блеске и заставляет форму появиться на экране более реалистично.
*  Начните с копии диффузной карты в сером цвете, что соответствует среднему блеску этого материала. Затем добавить светло-серый для более гладкой, блестящей, отражающей поверхности. Полученное изображение похоже на черно-белый вариант диффузной карты.
*  Вы можете использовать цвета в карте отражений чтобы создать некоторые отражающие эффекты (металлический блеск).


== Бесшовные плиточные текстуры


image::http///jmonkeyengine.googlecode.com/svn/trunk/engine/test-data/Textures/Terrain/BrickWall/BrickWall.jpg[BrickWall.jpg,with="128",height="128",align="right"]

Плитка очень простой, часто используемый тип текстуры. Когда текстурируется широкое пространство (например стены, полы), вы не создаете одну огромную текстуру - вместо этого вы создаете небольшую текстуру далее множественно используется для заполнения области.


Бесшовных текстуры-файл изображения который был разработан или модифицирован таким образом, что он может быть использован в качестве плитки: правый край соответствует левому краю, и верхним край соответствует нижнему краю.Зритель не может сразу определить, где начинается одно и начинается следующие, создавая тем самым иллюзию огромной текстуры. Недостатком является то, что плитка становится видимой, когда область рассматривается на расстоянии. Также вы не можете использовать его на более сложных моделях, такие как персонаж.


См. также это руководство на link:http://www.photoshoptextures.com/texture-tutorials/seamless-textures.htm[Как сделать бесшовные текстуры в Photoshop].



== UV-карта / Развернутая текстура


image::http///jmonkeyengine.googlecode.com/svn/trunk/engine/test-data/Models/Ferrari/Car.jpg[Car.jpg,with="128",height="128",align="right"]



Создание текстуры для куба это легко - но как насчет лица персонажа и его конечностей? Для более сложных объектов, вы проектируете текстуру таким же образом, как шаблон для кройки портного: один файл изображения содержит контуры передней, задней и боковой части объекта, рядом друг с другом. Конкретные направления плоской текстуры (UV координаты) отображены на определенные области 3D-модели (XYZ координаты), отсюда и название карты UV. С помощью UV-карт (также известный как развернутые текстуры) одна модель может иметь различные текстуры на каждой стороне. Вы создаете одну соответствующие UV карту для каждой текстуры.


Получение швов и карты имеет решающее значение: Вы должны использовать графический инструмент такой как Blender для создания UV-карт (Texture Atlas). Это занимает время на создание, зато UV-карта модели выглядят намного более профессиональной.



== Карты окружающей среды


image::http///jmonkeyengine.org/wp-content/uploads/2010/10/glass-teapot1.png[glass-teapot1.png,with="160",height="90",align="right"]



Карты окружающей среды или отражений используется для создания впечатления отражения и преломления в реальном времени. Это быстрее (но менее точно), чем метод трассировки лучей используемых в оффлайн-приложения визуализации.


Вы можете создать кубическую карту для представления вашей среды; Сферические карты также можно использовать, но они часто выглядят искаженными. В основном вы создаете карту окружения как набор изображений в 360 градусов обзора сцены - это очень похоже на скайбокс.Карта окружающей среды рендерится на текстуру отражающей поверхности, что приводит к эффекту “стекло / зеркало / вода. Так же, как и скайбокс, карты отражения является лишь статичными, такие динамично вещи как игрок ходьба не являются частью отражения. (!)


См. также: <<jme3/advanced/water#,Water>>.



== MIP Текстурные карты

MIP карта - это когда вы предоставляете одну текстуру в двух или трех разрешениях в одном файле (MIP = “Великое в малом = “много в одном). В зависимости от того, насколько близко (или далеко) камера, jME3 автоматически отображает большее (или меньшее) разрешение текстуры для объекта. Таким образом, объекты выглядят гладкими с близкого расстояния, но не тратятся ресурсы компьютера при обзоре из далека. Это всегда хорошо, но требует больше времени на создание и больше места для хранения текстур. Если вы не создаете вручную подобные ресурсы то jMonkeyEngine создает основные MIP карты при автоматической оптимизации.



== Процедурные текстуры

Процедурная текстура генерируется из одного повторяющегося небольшого изображения, а также некоторых псевдослучайных цветовых градиентов. Процедурные текстуры выглядят более естественно, чем статические прямоугольные текстуры и они выглядят менее искаженным на сферах. На больших сетках их повторяемость гораздо менее заметна чем с черепичными бесшовными текстурами. Процедурные текстуры идеально подходят для большой площади как трава, почва, камни, ржавчина и стены. Используйте link:http://jmonkeyengine.org/wiki/doku.php/sdk:neotexture[jMonkeyEngine SDK NeoTexture plugin] для их создания.



image::http///jmonkeyengine.org/wp-content/uploads/2010/10/neotexture-2.jpg[neotexture-2.jpg,with="380",height="189",align="center"]



См.также: link:http://www.blender.org/education-help/tutorials/materials/[Создание материала в Blender], link:http://en.wikibooks.org/wiki/Blender_3D:_Noob_to_Pro/Every_Material_Known_to_Man[Blender: Каждый материал известен человеку]



= Анимация

В 3D играх скелетная анимация используется для анимирования персонажей, но в принципе скелетный подход может быть распространен на любую 3D сетку (например шарнир открытия ящика так же можно считать примитивным суставом).


Если вы создаете 3D мультфильм, реализм анимированых персонажей, как правило, является проблемой: движение может выглядеть неестевственным, как механическое или сломанные конечности, персонаж как будто плавает или ломается. Профессиональные дизайнеры вкладывать в игру много усилий, чтобы сделать анимацию персонажа более естественной и в том числе link:http://en.wikipedia.org/wiki/Motion_capture[запись движения].



== Rigging и Skinning


image::http///pub.admc.com/misc/jme/blenderjmetut/blenderswordsman.png[blenderswordsman.png,with="195",height="151",align="right"]



Анимированный персонаж имеет арматуру внутреннего скелета (кости) и внешнюю поверхность (кожа).Кожа является самой приметной на персонаже, сюда входит и одежда. Кости не видны и используются для интерполяции (Calculate), морфинг кожи.


JME3, игровой движок, загружает только готовую анимацию. Вы должны использовать инструменты (например, Blender), чтобы создать/настроить (кости и кожу как живые) персонажа.


.  *Rigging:* Конструкция скелета персонажа.
**  Создание нескольких костей и как уменьшить сложность.
**  Кости соединены в иерархическую структуру: Перемещение одной кости может потянуть за собой другую (например ладонь тянет за собой предплечье).
**  Именование костей происходит по определенной схеме и 3D движок знает что к чему.

.  *Skinning:* Ассоциация отдельных костей с соответствующими участками кожи.
**  Каждая кость соединена с участком кожи. Анимация (невидимо) кости тянет (видимо) кожа вместе с ней. +
Например бедренная кость соединена с верхней кожей ног.
**  Одной части кожи может быть приписано более чем одна кость (например колено, локоть).
**  Связь между костями и кожей постепенна: Вы назначаете веса каждому полигону кожи который будет зависит от любого движения кости. +


.  *Ключевая Анимация:* Ключевой кадр одного записанного снимка - последовательности перемещений.
**  Ряд ключевых кадров составляет одну анимацию.
**  Каждая модель может иметь несколько анимаций. Каждая анимация имеет имя для её идентификации (например, “идти, “атака, “прыжок).
**  Вы указываете в вашей игре код ключевого кадра анимации для её загрузки когда в играете.


“


*  Трансформация (преобрзование) проще чем анимация. Иногда геометрические преобразования уже похоже на анимацию: Например вращающаяся ветряная мельница, пульсирующий чужеродный шар энергии, перемещение стержней машины. Преобразования можно легко сделать методами доступными в JME3.
*  Анимация однако является более сложной и кодируются в специальном формате (ключевой кадр). Искажения кожи и сложные серии движений записываются во внешних редакторах и проигрываються в jME3.





== Кинематика

*  Прямая кинематика: “Учитывая углы всех суставов персонажа, какова позиция рук?
*  Инверсная кинематика: “Учитывая положение рук персонажа, каковы углы всех суставов?


== Контроллер и каналы

В приложении JME3 вы регистрируете анимированные моделей в контроллере анимаций. Контроллер дает вам доступ к имеющимся последовательностям анимации. Контроллер имеет несколько каналов, каждый каналы может запустить одну последовательность анимации за один раз. Чтобы запустить несколько последовательностей вы создаете несколько каналов и запускаете их параллельно.



= Искуственный интелект (ИИ)

Non-player (под упарвлением компьютера) персонажи (NPC) имеют смысл в игре если они не тупо врезаются в стены или слепо идут на линию огня. Вы хотите чтобы NPC, “знали окружающую обстановку и и принимали решения на основе текущей ситуации - в противном случае игрок может просто игнорировать их. Наиболее распространенный случай использования это когда вы хотите сделать возможность взаимодействия с ними таким образом чтобы они предлагали более интересные задачи для игрока.


“Smart игровые элементы - это искусственные интеллектуальные агенты (AI agents).АгентИИ может быть использован для создания врагов НПС а также обученных животных, вы также можете использовать их для создания автоматических систем охранной сигнализации которые блокируют двери и поднимают тревогу после того как появится злоумышлиник.


Область возможностей искусственного интеллекта, среди прочего, включает:


*  *Знание* – Знание _ Данные _ к которым Агент ИИ имеет доступ и на которых ИИ принимает решения. Реалистичные агенты знают только когда видят и слышат что то. Это означает, что информация может быть скрыта от ИИ, чтобы игра была справедливой. У вас может быть всезнающий ИИ или вы можете позволить только некоторый доступ агентам к матрице информации. +
Пример: После того как игрок подойдет достаточно близко только несколько охранников ИИ с двусторонней радиосвязью начнут движение к позиции игрока, в то время как многие другие охранники даже не подозревают ничего.
*  *Планирование цели* – Планирование - это когда ИИ агент _ принимает меры _. Каждый ИИ агент имеет приоритет для достижения конкретной цели. При программировании вы разделяете цель агента на несколько подзадач. Агент, в соответсвии с текущей обстановкой, выбирает доступную тактику или стратегию в соответствии с приоритетом. Агент неоднократно проверяет соответствует ли текущее состояние цели. В случае неудачи агент должен отказаться от текущей тактики/стратегии и попробовать другую. +
Пример: агент ищет лучший путь к достижению основного игрока в меняющихся условиях, избегая ловушек. Агент гонится за игроком с целью его ликвидации. Агент скрывается от игрока с целью тихого убийства.
*  *Решение проблем* – Решение проблемы - это когда агент _ реагирует на события _, препятствия, которые стоят между ним и его целью. Агент использует набор фактов и правил что бы определить в каком состоянии он находится - и вызываются восприятия похожие на боль, агонию, скуку или он оказывается в ловушке. В каждой ситуации только определенное подмножество реакций имеет смысл. Фактически реакция также зависит от цели агента, так как реакция не должна отменять цель! +
Пример: Если игрок подходит то агент атакует, скрывается или поднимет тревогу? В то время как агент находится в режиме ожидания он ставит ловушки или исцеляет себя или перезаряжает магические руны? Если есть опасность для собственной жизни агенты пытаются убежать или становится камикадзе?

Более продвинутые ИИ также используют нейронные сети в коде.


Есть много интересных ресурсов обьясняющих различные типы ИИ:


*  link:http://www.policyalmanac.org/games/aStarTutorial.htm[A* (A-Star) поиск пути для начинающих]
*  link:http://theory.stanford.edu/~amitp/GameProgramming/[A* (A-star) теория поиска пути]
*  link:http://hem.fyristorg.com/dawnbringer/z-path.html[&quot;Z-Path&quot; algorithm] (поиск обратного пути)
*  link:http://web.media.mit.edu/~jorkin/goap.html[GOAP -- Целеноправленное планирование деятельности]
*  link:http://neuroph.sourceforge.net/[Neuroph -- Java Neural Networks]
*  …


= Математика


image::jme3/intermediate/coordinate-system.png[coordinate-system.png,with="235",height="210",align="right"]




== Координаты

Координаты представляют собой положение в системе координат. Координаты считаются относительно начала в (0,0,0). В 3D-пространстве необходимо задать три значения координат чтобы найти точку: X (справа), Y (вверх), Z (к себе). Кроме того, -X(слева), -Y (вниз), -Z (от себя).
В отличие от координат расположения вектора не направлены куда либо.



=== Источник/Начало

Источник - центральная точка в 3D мире где встречаются три оси. Всегда находится в координатах (0,0,0).


*Пример:* `Vector3f origin = new Vector3f(Vector3f.ZERO);`



== Вектор

У вектора есть длина и направление как у стрелки в 3D пространстве. Вектор начинается в координатах (x1, y1, z1) или в начале и заканчивается в целевых координатах (x2, y2, z2). Обратное направления выражено отрицательными величинами.


*Пример:* 


[source,java]

----
Vector3f v = new Vector3f( 17f , -4f , 0f ); // начало находится в (0/0/0)
Vector3f v = new Vector3f(8f , 0f , 33f).add(new Vector3f(0f , -2f , -2f)); // начало и конец, направление (8,-2,31)
----


=== Единичные векторы

_Единичный вектор _ является основным вектором с длиной в одну единицу мира. Так как его длина фиксирована (и таким образом это может указать только на одно расположение так или иначе), единственная интересная вещь об этом векторе - его направление


*  `Vector3f.UNIT_X`  = ( 1, 0, 0) = право
*  `Vector3f.UNIT_Y`  = ( 0, 1, 0) = вверх
*  `Vector3f.UNIT_Z`  = ( 0, 0, 1) = на себя
*  `Vector3f.UNIT_XYZ` = по диагонали право-вверх-на себя

Инвертируйте значение что бы изменить направление, например (-1, 0, 0) = влево.



=== Нормализованный вектор

_Нормированный вектор _ это обычный _ единичный вектор _. Нормированный вектор это не то же самое что _ вектора нормали (на поверхности)_.
Когда вы нормализуете вектор он по-прежнему имеет то же направление но вы потеряете всю информацию о том куда вектор первоначально указывал.


*Пример:* Вы нормализовали вектора для расчета углов.



=== Вектор нормалей плоскости


image::jme3/300px-surface_normal.png[300px-surface_normal.png,with="",height="",align="right"]

Нормаль к поверхности представляет собой вектор перпендикулярный (ортогональный) к плоскости.
Вы рассчитываете нормали к поверхности путем вычисления векторного произведения.



=== Произведение векторов

Векторное произведение - это расчетов которые вы используете чтобы найти перпендикулярный вектор (ортогональный,90°).
В 3D пространстве говорить об ортогональном имеет смысл только по отношению к плоскости. Всего два вектора нужно что бы однозначно определить плоскость. Произведение двух векторов, `V1×V2`, это новый вектор, перпендикулярный этой плоскости. Вектор перпендикулярный плоскости называется _ нормаль к поверхности _.


*Пример:* Вектор х и вектор у вместе определяют X/Y плоскость. Вектор перпендикулярный к ним по оси Z. JME считает, что это равенство верно: +

`(Vector3f.UNIT_X.cross(Vector3f.UNIT_Y)).equals(Vector3f.UNIT_Z)` == true



=== Преобразование

Трансформация - это вращение (поворот), масштабирование (изменение размера) или перевод (перемещение) объектов в 3D сцене. 3D движки предлагают простые методы, чтобы вы могли написать код который трансформирует узлы.


Пример: Падение и вращение керпичей в 3D Tetris.



=== Slerp

Slerp - это сферическая линейная интерполяция. slerp - интерполированное преобразование, которое используется в качестве простой “анимации в 3D движках. Определяете начальное и конечное состояние и slerp интерполирует постоянный переход скорости от одного состояния к другому. Можете проиграть движение, приостановить его в различных состоянии, в процентах (значения между 0.0 и 1.0) и проиграть его назад и вперед. link:http://jmonkeyengine.org/javadoc/com/jme3/math/Quaternion.html#slerp(com.jme3.math.Quaternion,%20com.jme3.math.Quaternion,%20float)[JavaDoc: slerp()]


Пример: Падение метеорита на землю в кратер, с начальными значениями “position p1, rotation r1, scale s1 но после сжигания в атмосфере  и падения в кратер иные “position p2, rotation r2, scale s2.


<<jme3/math#,Узнайте больше о 3D математике здесь.>>



= Жаргон разработчиков игр

*  link:http://www.gamasutra.com/view/feature/6504/a_game_studio_culture_dictionary.php?print=1[Культура игровой студии]


= 3D-графика Терминология WIKI

*  link:http://en.wikipedia.org/wiki/User:Jreynaga/Books/3D_Graphics_Terms[http://en.wikipedia.org/wiki/User:Jreynaga/Books/3D_Graphics_Terms]
