

= Как Использовать Материалы

Английская версия: <<jme3/intermediate/how_to_use_materials#,How to Use Materials>>


Геометрия (сетка) это всего лишь форма объекта. jMonkeyEngine не удастся отобразить форму, ничего не зная о её поверхностных свойствах. Вам необходимо применить цвет или текстуру к поверхности вашего геометрии, чтобы сделать её видимой. В jMonkeyEngine, цветов и текстуры представлены в виде объекта Материал. (Альтернативой могла бы быть также загрузка модели, которая включает в себя материалы, вырабатываемые mesh editor, таких как Blender.)


*  Все Геометрия должны иметь Материалы, которые определяет цвет или текстуру.
*  Каждый Материал основан на Material Definition файле. +
Примеры Material Definitions: Lighting.j3md, Unshaded.j3md

You want to make the most of your 3D models by specifying good looking material parameters. The developers must be in contact with the graphic designers regarding which of the <<jme3/advanced/materials_overview#,Material properties>> they intend to use in their 3D models. Вы должны иметь понимание того, чем являются <<jme3/terminology#materialstextures,текстурированные карты>> чтобы иметь возможность использовать материалы, текстуры. 


<<jme3/advanced/light_and_shadow#,Источник света>>“*невидимый*


Если вы хотите более продвинутые справочная информация: вы можете узнать больше о <<jme3/advanced/material_definitions#,Material Definitions>>  в целом здесь. Вы можете найти полный список Параметров материала в <<jme3/advanced/materials_overview#,Material Definitions Properties>>. Ниже представляем вам наиболее часто используемых случаев. Как правило, инициализируются объекты Материал в методе `simpleInitApp()` как настроить их с помощью setters, описанно здесь. Затем загрузите материалы, с помощью `myGeometry.setMaterial(mat)`. 



== Пример кода

В следующем примере предположим, что вы загрузили Геометрию названую myGeometry, и хотите назначить материал.


В этом примере создается простой синий незатененный материал: Использовать его для абстрактных объектов, которые не нуждаются в освещение/затенения, например, небо, графический интерфейс и узлы афиши, tiles/cards, или toons.


[source,java]

----
Spatial myGeometry = assetManager.loadModel("Models/Teapot/Teapot.j3o");
Material mat = new Material(assetManager,  // Создаем новый материал и...
    "Common/MatDefs/Misc/Unshaded.j3md");  // ... укажем .j3md файл используем (незатененной).
mat.setColor("Color", ColorRGBA.Blue);     // Установим некоторые параметры, например, синий.
myGeometry.setMaterial(mat);               // Используем новый материал на геометрии.

----

В этом примере создается link:http://en.wikipedia.org/wiki/Phong_reflection_model[Phong]-illuminated синего материала. Используйте его для освещения, натуралистических объектов, таких как персонажи, здания, территорий, транспортные средства. Нужен источник света, в противном случае они будут невидимы.


[source,java]

----
Spatial myGeometry = assetManager.loadModel("Models/Teapot/Teapot.j3o");
Material mat = new Material(assetManager,  // Создаем новый материал и...
    "Common/MatDefs/Light/Lighting.j3md"); // ... укажем .j3md файл используем  (с подсветкой).
mat.setBoolean("UseMaterialColors",true);  // Установим некоторые параметры, например, синий.
mat.setColor("Ambient", ColorRGBA.Blue);   // ... цвет этого объекта
mat.setColor("Diffuse", ColorRGBA.Blue);   // ... цвет света отражается
myGeometry.setMaterial(mat);               // Используем новый материал на геометрии.

----

<<sdk/material_editing#,store Material properties in a .j3m file>>


[source,java]

----
myGeometry.setMaterial( assetManager.loadMaterial("Materials/myMaterial.j3m"));
----





== Цветные или текстурированные

Каждый материал должен иметь, по крайней мере, материала, цвета или текстуры. Некоторые дополнительные особенности материала требуют также их комбинации.



=== Цветной

Дать незатененному материалу цвет:


.  Укажите свойство color 
[source,java]

----
mat.setColor("Color", ColorRGBA.Blue); // с Unshaded.j3md
----


Дать Phong-illuminated цвету материала:


.  Активировать  цвета материал: 
[source,java]

----
mat.setBoolean("UseMaterialColors",true); // с Lighting.j3md
----

.  Укажите, по крайней мере Diffuse и Ambient цвета. Set both to the same color in the standard case. 
[source,java]

----
mat.setColor("Diffuse", ColorRGBA.Blue ); // с Lighting.j3md
mat.setColor("Ambient", ColorRGBA.Blue ); // с Lighting.j3md
----



=== Текстурированние

Дать незатененной(unshaded) материал текстуре:


*  Укажите хотя бы цветовую палитру: 
[source,java]

----
mat.setTexture("ColorMap", assetManager.loadTexture("Textures/monkey.png")); // с Unshaded.j3md
----


Дать Phong-illuminated материал текстуре:


*  Укажите по крайней мере DiffuseMap текстуры: 
[source,java]

----
mat.setTexture("DiffuseMap", assetManager.loadTexture("Textures/wood_diffuse.png")); // с Lighting.j3md
----





[source,java]

----
geometry.scaleTextureCoordinates(new Vector2f(0.5f, 0.5f));
----




Все остальные Texture Maps или Материалы являются необязательными. Если их использовать умело, они делают модели выглядящей очень элегантно.



== (Необязательно) Неровности

A NormalMap (also called BumpMap) is an extra colored texture that describes the fine bumpy details of the Material surface. E.g. fine cracks, pores, creases, notches. Using a BumpMap is more efficient than trying to shape the mesh to be bumpy.


To add a BumpMap (this only makes sense for illuminated Materials):


.  Generate normal vectors information for the Mesh (not for the Geometry!) using `com.jme3.util.TangentBinormalGenerator`. 
[source,java]

----
TangentBinormalGenerator.generate(mesh);
----

.  Specify the `NormalMap` texture for the Material. 
[source,java]

----
mat.setTexture("NormalMap", assetManager.loadTexture("Textures/wood_normal.png")); // with Lighting.j3md
----


link:http://en.wikipedia.org/wiki/Bump_mapping[Learn more about creating and using NormalMaps and BumpMaps here.]



== (Необязательно) Блестящий

To activate Shininess (this only makes sense for illuminated Materials):


.  Specify the `Shininess` intensity the Material. +
Shininess is a float value between 1 (rough surface with blurry shininess) and 128 (very smooth surface with focused shininess)
[source,java]

----
mat.setFloat("Shininess", 5f);
----

.  Activate material colors: 
[source,java]

----
mat.setBoolean("UseMaterialColors",true);
----

.  Specify the `Specular` and `Diffuse` colors of the shiny spot. +
Typically you set Specular to the ColorRGBA value of the light source, often RGBA.White.
[source,java]

----
mat.setColor("Specular",ColorRGBA.White);
mat.setColor("Diffuse",ColorRGBA.White);
----

.  (Optional) Specify a `SpecularMap` texture. +
You optionally hand-draw this grayscale texture to outline in detail where the surface should be more shiny (whiter grays) and where less (blacker grays). If you don't supply a SpecularMap, the whole material is shiny everywhere. 
[source,java]

----
mat.setTexture("SpecularMap", assetManager.loadTexture("Textures/metal_spec.png")); // with Lighting.j3md
----


To deactivate shininess


*  Set the `Specular` color to `ColorRGBA.Black`. Do not just set `Shininess` to 0.
[source,java]

----
mat.setColor("Specular",ColorRGBA.Black);
----



== (Необязательно) Светящийся

To activate glow:


.  Add one <<jme3/advanced/bloom_and_glow#,BloomFilter PostProcessor>> in your simpleInitApp() method (only once, it is used by all glowing objects).
[source,java]

----
FilterPostProcessor fpp=new FilterPostProcessor(assetManager);
BloomFilter bloom = new BloomFilter(BloomFilter.GlowMode.Objects);
fpp.addFilter(bloom);
viewPort.addProcessor(fpp);
----

.  Specify a `Glow` color. +
A ColorRGBA value of your choice, e.g. choose a warm or cold color for different effects, or white for a neutral glow.
[source,java]

----
mat.setColor("GlowColor",ColorRGBA.White);
----

.  (Optional) Specify a `GlowMap` texture. +
This texture outlines in detail where the DiffuseMap texture glows. If you don't supply a GlowMap, the whole material glows everwhere.  
[source,java]

----
mat.setTexture("GlowMap", assetManager.loadTexture("Textures/alien_glow.png"));
----


To deactivate glow:


*  Set the `Glow` color to `ColorRGBA.Black`.
[source,java]

----
mat.setColor("GlowColor", ColorRGBA.Black);
----


Learn more about <<jme3/advanced/bloom_and_glow#,Bloom and Glow>>.



== (Необязательно) Прозрачный

Most Material Definitions support an alpha channel to make a model opaque, translucent, or transparent.


*  Alpha=1.0f makes the color opaque (default), 
*  Alpha=0.0f make the color fully transparent
*  Alpha between 0f and 1f makes the color more or less translucent.

To make a Geometry transparent or translucent:


.  Specify which areas you want to be transparent or translucent by specifying the alpha channel:
**  (For colored Materials) In any RGBA color, the first three are Red-Green-Blue, and the last float is the Alpha channel. For example, to replace ColorRGBA.Red with a translucent red: 
[source,java]

----
mat.setColor("Color", new ColorRGBA(1,0,0,0.5f));
----

**  (For textured Materials) Supply an AlphaMap that outlines which areas are transparent. 
[source,java]

----
mat.setTexture("AlphaMap", assetManager.loadTexture("Textures/window_alpha.png"));
----

**  (For textured Materials) If the DiffuseMap has an alpha channel, use: 
[source,java]

----
mat.setBoolean("UseAlpha",true);
----


.  Specify BlendMode Alpha for the Material. 
[source,java]

----
mat.getAdditionalRenderState().setBlendMode(BlendMode.Alpha);
----

.  Put the Geometry (not the Material!) in the appropriate render queue bucket. +
Objects in the translucent bucket (e.g. particles) are not affected by SceneProcessors (e.g. shadows). Objects in the transparent bucket (e.g. foliage) are affected by SceneProcessors (e.g. shadows).
**  
[source,java]

----
geo.setQueueBucket(Bucket.Translucent); 
----

**  
[source,java]

----
geo.setQueueBucket(Bucket.Transparent); 
----


.  (Optional) Specify other material settings.
[cols="3", options="header"]
|===

a|Standard Material Transparency
a|Описание
a|Пример

a|getAdditionalRenderState().setBlendMode(BlendMode.Off);
a|Это по умолчанию, нет прозрачности.
a|Использовать для всех непрозрачных объектов, таких как стены, полы, люди…

a|getAdditionalRenderState().setBlendMode(BlendMode.Alpha);
a|Interpolates the background pixel with the current pixel by using the current pixel's alpha.
a|Это наиболее часто используемый BlendMode для прозрачности и полупрозрачности: матового стекла, льда, стекла, Альфа-смешивания текстур растительности… 

a|getAdditionalRenderState().setDepthWrite(false);
a|Отключение запись значения глубины пикселя в буфер глубины.
a|Deactivate this on Materials if you expect two or more transparent/translucent objects to be obscuring one another, but you want to see through both.

a|getAdditionalRenderState().setAlphaTest(true) +
getAdditionalRenderState().setAlphaFallOff(0.5f);
a|Enables Alpha Testing and uses an AlphaDiscardThreshold as alpha fall-off value. This means that gradients in the AlphaMap are no longer interpreted as soft translucency, but parts of the texture become either fully opaque or fully transparent. Only pixels above the alpha threshold (e.g. 0.5f) are rendered. 
a|Activate Alpha Testing for (partially) *transparent* objects such as foliage, hair, etc. +
Deactivate Alpha Testing for gradually *translucent* objects, such as colored glass, smoked glass, ghosts.

|===




[source,java]

----
mat.setBoolean("UseAlpha",true);
----

–“



== (Необязательно) Каркас

Additionally to the above settings, you can switch off and on a wireframe rendering of the mesh. Since a wireframe has no faces, this temporarily disables the other Texture Maps.

[cols="3", options="header"]
|===

a|Свойства Материала
a|Описание
a|Пример

a|getAdditionalRenderState().setWireframe(true);
a|Режим показа (текстурированно) материал в каркасном режиме. Каркас дополнительно использует Материал со значением `Color`.
a|UИспользование каркасных моделей для отладки сетки, или для “matrix или эффекта “holodeck.

|===
<tags><tag target="material" /><tag target="texture" /><tag target="effect" /><tag target="wireframe" /><tag target="light" /><tag target="documentation" /></tags>
