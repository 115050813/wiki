

= Полигональная Сетка

Английская версия: <<jme3/advanced/mesh#,Mesh>>



image::jme3/dolphin-mesh.png[dolphin-mesh.png,with="",height="",align="right"]



Все видимые элементы игры в сцене, будь то модель или фигура, состоят из полигональных сеток. В JME3 есть com.jme3.scene.Mesh класс, который представляет все сетки.


*  Сетки состоят из треугольников: `getTriangleCount(…)` и `getTriangle(…)`
*  Каждая сетка имеет уникальный ID: `getId()`
*  Сетки имеют преобразований: местоположение (по местному расположения), вращение, масштабирование.
*  Сетки имеют bounding volume. jME3 можете обнаружить пересечение (то есть, без физического столкновения) между сетками, или между сетками и 2D элементами, такими как лучи: `collideWith()`.
*  Сетки блокируются с `setStatic()` и разблокируются с `setDynamic()`. 
**  Static Meshes не может быть изменен, но более быстро оптимизируется (они могут быть заранее рассчитаны).
**  Динамические сетки могут изменятся, но не оптимизированы и медленнее.


У Вас есть несколько вариантов, когда <<документация/jme3_ru/расширенная/spatial_ru#,Геометрии создаются из сетки>>:


*  Используйте встроенные <<документация/jme3_ru/расширенная/фигура#,Фигуры>> как и сетки; 
*  Загружайте <<документация/jme3_ru/расширенная/3d_модель#,3D Модели>> (то есть, сеток, созданных во внешних приложениях); или
*  Создать в свободной форме <<документация/jme3_ru/расширенная/пользовательские_сетки#,Пользовательские Сетки>> программно. 


== Vertex Buffer

В VertexBuffer содержит определенный тип данных Геометрий, используемых сеток. Каждый VertexBuffer установившись на сетку отправляется в качестве атрибута vertex shader, чтобы быть обработаным.



=== Mesh Vertex Buffers
[cols="2", options="header"]
|===

a|Vertex Buffer Type
a|Описание

a|Type.Position 
a|Положение вершины (3 floats)

a|Type.Index 
a| Задает индекс буфера, должны содержать целочисленные данные.

a|Type.TexCoord 
a| координаты текстуры

a|Type.TexCoord2 
a| координаты текстуры #2

a|Type.Normal 
a| Normal вектор, нормированный.

a|Type.Tangent 
a| Касательный вектор, нормированный.

a|Type.Binormal 
a| Binormal vector, normalized.

a|Type.Color 
a| Цвет и Alpha (4 floats)

a|Type.Size 
a|Размер точки при использовании point buffers.

a|Type.InterleavedData 
a| Задает источник данных для различных vertex buffers когда используется чередование.

a|Type.BindPosePosition 
a| Начальное положение вершины, используется с анимацией.

a|Type.BindPoseNormal 
a| Начальный нормалей вершин, используется с анимацией

a|Type.BoneWeight 
a| Bone weights, используется с анимацией

a|Type.BoneIndex 
a| Bone indices, используется с анимацией

|===


=== Mesh Свойства
[cols="2", options="header"]
|===

a|Mesh метод
a|Описание

a|setLineWidth(1)
a|толщина линии при использовании Mode.Lines

a|setPointSize(4.0f)
a|толщина точки при использовании Mode.Points

a|setBound(boundingVolume)
a|если вам необходимо указать пользовательский оптимизированный bounding volume

a|setStatic()
a|Замки mesh-так что вы не можете изменить её больше, тем самым оптимизируя свои данные (быстрее).

a|setDynamic()
a|Отпирает сетки, так что вы можете её изменить, но тем самым будет un-optimize данные (медленнее).

a|setMode(Mesh.Mode.Points)
a|Используется для установки сетки режимы рендеринга, см. ниже.

a|getId()
a|возвращает ID сетки

a|getTriangle(int,tri)
a|возвращает данные из треугольника число`int` в переменной `tri`

a|scaleTextureCoordinates(Vector2f)
a|Как текстура будет растянута на всю сетку.

|===


=== Mesh Rendering Modes
[cols="2", options="header"]
|===

a|Mesh Режим
a|Описание

a|Mesh.Mode.Points
a|Посмотреть только угловых точек (вершин), сетки

a|Mesh.Mode.Lines
a|Посмотреть линий (ребер) сетки

a|Mesh.Mode.LineLoop
a|?

a|Mesh.Mode.LineStrip
a|?

a|Mesh.Mode.Triangles
a|?

a|Mesh.Mode.TriangleStrip
a|?

a|Mesh.Mode.TriangleFan
a|?

a|Mesh.Mode.Hybrid
a|?

|===


=== Уровень Детализации

Дополнительно пользовательские сетки могут иметь LOD (уровень детализации оптимизации) что рендерится более или менее подробно, в зависимости от расстояния камеры до сетки. Вы должны указать несколько vertex buffers, по одной для каждого уровня детализации, который вы хотите (очень далеко с несколькими деталями, крупным планом со всеми подробностями, и что-то в среднем). Используйте `setLodLevels(VertexBuffer[] lodLevels)`. 

<tags><tag target="spatial" /><tag target="node" /><tag target="mesh" /><tag target="geometry" /><tag target="scenegraph" /></tags>
